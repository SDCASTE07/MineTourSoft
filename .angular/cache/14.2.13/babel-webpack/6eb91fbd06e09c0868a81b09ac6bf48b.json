{"ast":null,"code":"import _slicedToArray from \"C:/paper-kit-2-angular-master/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _wrapNativeSuper from \"C:/paper-kit-2-angular-master/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _inherits from \"C:/paper-kit-2-angular-master/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/paper-kit-2-angular-master/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"C:/paper-kit-2-angular-master/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/paper-kit-2-angular-master/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _toConsumableArray from \"C:/paper-kit-2-angular-master/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"C:/paper-kit-2-angular-master/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { existsSync, open, read, closeSync, close } from 'fs';\nimport { hostname } from 'os';\nimport { Stream } from 'stream';\nimport { TextEncoder, TextDecoder } from 'util';\nimport { createHmac } from 'crypto';\nimport { EventEmitter } from 'events';\nimport { Socket } from 'net';\nimport { connect as _connect, TLSSocket, createSecureContext } from 'tls';\n/*\n * Operator tokens and which tokens are expected to end the sequence\n */\n\nvar OPERATORS = new Map([['\"', '\"'], ['(', ')'], ['<', '>'], [',', ''], // Groups are ended by semicolons\n[':', ';'], // Semicolons are not a legal delimiter per the RFC2822 grammar other\n// than for terminating a group, but they are also not valid for any\n// other use in this context.  Given that some mail clients have\n// historically allowed the semicolon as a delimiter equivalent to the\n// comma in their UI, it makes sense to treat them the same as a comma\n// when used outside of a group.\n[';', '']]);\n/**\n * Tokenizes the original input string\n *\n * @param {string | string[] | undefined} address string(s) to tokenize\n * @return {AddressToken[]} An array of operator|text tokens\n */\n\nfunction tokenizeAddress() {\n  var address = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n  var _a, _b;\n\n  var tokens = [];\n  var token = undefined;\n  var operator = undefined;\n\n  var _iterator = _createForOfIteratorHelper(address.toString()),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var character = _step.value;\n\n      if (((_a = operator === null || operator === void 0 ? void 0 : operator.length) !== null && _a !== void 0 ? _a : 0) > 0 && character === operator) {\n        tokens.push({\n          type: 'operator',\n          value: character\n        });\n        token = undefined;\n        operator = undefined;\n      } else if (((_b = operator === null || operator === void 0 ? void 0 : operator.length) !== null && _b !== void 0 ? _b : 0) === 0 && OPERATORS.has(character)) {\n        tokens.push({\n          type: 'operator',\n          value: character\n        });\n        token = undefined;\n        operator = OPERATORS.get(character);\n      } else {\n        if (token == null) {\n          token = {\n            type: 'text',\n            value: character\n          };\n          tokens.push(token);\n        } else {\n          token.value += character;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return tokens.map(function (x) {\n    x.value = x.value.trim();\n    return x;\n  }).filter(function (x) {\n    return x.value.length > 0;\n  });\n}\n/**\n * Converts tokens for a single address into an address object\n *\n * @param {AddressToken[]} tokens Tokens object\n * @return {AddressObject[]} addresses object array\n */\n\n\nfunction convertAddressTokens(tokens) {\n  var addressObjects = [];\n  var groups = [];\n  var addresses = [];\n  var comments = [];\n  var texts = [];\n  var state = 'text';\n  var isGroup = false;\n\n  function handleToken(token) {\n    if (token.type === 'operator') {\n      switch (token.value) {\n        case '<':\n          state = 'address';\n          break;\n\n        case '(':\n          state = 'comment';\n          break;\n\n        case ':':\n          state = 'group';\n          isGroup = true;\n          break;\n\n        default:\n          state = 'text';\n          break;\n      }\n    } else if (token.value.length > 0) {\n      switch (state) {\n        case 'address':\n          addresses.push(token.value);\n          break;\n\n        case 'comment':\n          comments.push(token.value);\n          break;\n\n        case 'group':\n          groups.push(token.value);\n          break;\n\n        default:\n          texts.push(token.value);\n          break;\n      }\n    }\n  } // Filter out <addresses>, (comments) and regular text\n\n\n  var _iterator2 = _createForOfIteratorHelper(tokens),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var token = _step2.value;\n      handleToken(token);\n    } // If there is no text but a comment, replace the two\n\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  if (texts.length === 0 && comments.length > 0) {\n    texts = _toConsumableArray(comments);\n    comments = [];\n  } // http://tools.ietf.org/html/rfc2822#appendix-A.1.3\n\n\n  if (isGroup) {\n    addressObjects.push({\n      name: texts.length === 0 ? undefined : texts.join(' '),\n      group: groups.length > 0 ? addressparser(groups.join(',')) : []\n    });\n  } else {\n    // If no address was found, try to detect one from regular text\n    if (addresses.length === 0 && texts.length > 0) {\n      for (var i = texts.length - 1; i >= 0; i--) {\n        if (texts[i].match(/^[^@\\s]+@[^@\\s]+$/)) {\n          addresses = texts.splice(i, 1);\n          break;\n        }\n      } // still no address\n\n\n      if (addresses.length === 0) {\n        for (var _i = texts.length - 1; _i >= 0; _i--) {\n          texts[_i] = texts[_i].replace(/\\s*\\b[^@\\s]+@[^@\\s]+\\b\\s*/, function (address) {\n            if (addresses.length === 0) {\n              addresses = [address.trim()];\n              return ' ';\n            } else {\n              return address;\n            }\n          }).trim();\n\n          if (addresses.length > 0) {\n            break;\n          }\n        }\n      }\n    } // If there's still is no text but a comment exixts, replace the two\n\n\n    if (texts.length === 0 && comments.length > 0) {\n      texts = _toConsumableArray(comments);\n      comments = [];\n    } // Keep only the first address occurence, push others to regular text\n\n\n    if (addresses.length > 1) {\n      texts = [].concat(_toConsumableArray(texts), _toConsumableArray(addresses.splice(1)));\n    }\n\n    if (addresses.length === 0 && isGroup) {\n      return [];\n    } else {\n      // Join values with spaces\n      var address = addresses.join(' ');\n      var name = texts.length === 0 ? address : texts.join(' ');\n\n      if (address === name) {\n        if (address.match(/@/)) {\n          name = '';\n        } else {\n          address = '';\n        }\n      }\n\n      addressObjects.push({\n        address: address,\n        name: name\n      });\n    }\n  }\n\n  return addressObjects;\n}\n/**\n * Parses structured e-mail addresses from an address field\n *\n * Example:\n *\n *    \"Name <address@domain>\"\n *\n * will be converted to\n *\n *     [{name: \"Name\", address: \"address@domain\"}]\n *\n * @param {string | string[] | undefined} address Address field\n * @return {AddressObject[]} An array of address objects\n */\n\n\nfunction addressparser(address) {\n  var addresses = [];\n  var tokens = [];\n\n  var _iterator3 = _createForOfIteratorHelper(tokenizeAddress(address)),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var token = _step3.value;\n\n      if (token.type === 'operator' && (token.value === ',' || token.value === ';')) {\n        if (tokens.length > 0) {\n          addresses.push.apply(addresses, _toConsumableArray(convertAddressTokens(tokens)));\n        }\n\n        tokens = [];\n      } else {\n        tokens.push(token);\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  if (tokens.length > 0) {\n    addresses.push.apply(addresses, _toConsumableArray(convertAddressTokens(tokens)));\n  }\n\n  return addresses;\n}\n/**\n * @param {Date} [date] an optional date to convert to RFC2822 format\n * @param {boolean} [useUtc] whether to parse the date as UTC (default: false)\n * @returns {string} the converted date\n */\n\n\nfunction getRFC2822Date() {\n  var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();\n  var useUtc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (useUtc) {\n    return getRFC2822DateUTC(date);\n  }\n\n  var dates = date.toString().replace('GMT', '').replace(/\\s\\(.*\\)$/, '').split(' ');\n  dates[0] = dates[0] + ',';\n  var day = dates[1];\n  dates[1] = dates[2];\n  dates[2] = day;\n  return dates.join(' ');\n}\n/**\n * @param {Date} [date] an optional date to convert to RFC2822 format (UTC)\n * @returns {string} the converted date\n */\n\n\nfunction getRFC2822DateUTC() {\n  var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();\n  var dates = date.toUTCString().split(' ');\n  dates.pop(); // remove timezone\n\n  dates.push('+0000');\n  return dates.join(' ');\n}\n/**\n * RFC 2822 regex\n * @see https://tools.ietf.org/html/rfc2822#section-3.3\n * @see https://github.com/moment/moment/blob/a831fc7e2694281ce31e4f090bbcf90a690f0277/src/lib/create/from-string.js#L101\n */\n\n\nvar rfc2822re = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/;\n/**\n * @param {string} [date] a string to check for conformance to the [rfc2822](https://tools.ietf.org/html/rfc2822#section-3.3) standard\n * @returns {boolean} the result of the conformance check\n */\n\nfunction isRFC2822Date(date) {\n  return rfc2822re.test(date);\n} // adapted from https://github.com/emailjs/emailjs-mime-codec/blob/6909c706b9f09bc0e5c3faf48f723cca53e5b352/src/mimecodec.js\n\n\nvar encoder = new TextEncoder();\n/**\n * @see https://tools.ietf.org/html/rfc2045#section-6.7\n */\n\nvar RANGES = [[0x09], [0x0a], [0x0d], [0x20, 0x3c], [0x3e, 0x7e] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\n];\nvar LOOKUP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\nvar MAX_CHUNK_LENGTH = 16383; // must be multiple of 3\n\nvar MAX_MIME_WORD_LENGTH = 52;\nvar MAX_B64_MIME_WORD_BYTE_LENGTH = 39;\n\nfunction tripletToBase64(num) {\n  return LOOKUP[num >> 18 & 0x3f] + LOOKUP[num >> 12 & 0x3f] + LOOKUP[num >> 6 & 0x3f] + LOOKUP[num & 0x3f];\n}\n\nfunction encodeChunk(uint8, start, end) {\n  var output = '';\n\n  for (var i = start; i < end; i += 3) {\n    output += tripletToBase64((uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2]);\n  }\n\n  return output;\n}\n\nfunction encodeBase64(data) {\n  var len = data.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\n  var output = ''; // go through the array every three bytes, we'll deal with trailing stuff later\n\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += MAX_CHUNK_LENGTH) {\n    output += encodeChunk(data, i, i + MAX_CHUNK_LENGTH > len2 ? len2 : i + MAX_CHUNK_LENGTH);\n  } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n  if (extraBytes === 1) {\n    var tmp = data[len - 1];\n    output += LOOKUP[tmp >> 2];\n    output += LOOKUP[tmp << 4 & 0x3f];\n    output += '==';\n  } else if (extraBytes === 2) {\n    var _tmp = (data[len - 2] << 8) + data[len - 1];\n\n    output += LOOKUP[_tmp >> 10];\n    output += LOOKUP[_tmp >> 4 & 0x3f];\n    output += LOOKUP[_tmp << 2 & 0x3f];\n    output += '=';\n  }\n\n  return output;\n}\n/**\n * Splits a mime encoded string. Needed for dividing mime words into smaller chunks\n *\n * @param {string} str Mime encoded string to be split up\n * @param {number} maxlen Maximum length of characters for one part (minimum 12)\n * @return {string[]} lines\n */\n\n\nfunction splitMimeEncodedString(str) {\n  var maxlen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;\n  var minWordLength = 12; // require at least 12 symbols to fit possible 4 octet UTF-8 sequences\n\n  var maxWordLength = Math.max(maxlen, minWordLength);\n  var lines = [];\n\n  while (str.length) {\n    var curLine = str.substr(0, maxWordLength);\n    var match = curLine.match(/=[0-9A-F]?$/i); // skip incomplete escaped char\n\n    if (match) {\n      curLine = curLine.substr(0, match.index);\n    }\n\n    var done = false;\n\n    while (!done) {\n      var chr = void 0;\n      done = true;\n\n      var _match = str.substr(curLine.length).match(/^=([0-9A-F]{2})/i); // check if not middle of a unicode char sequence\n\n\n      if (_match) {\n        chr = parseInt(_match[1], 16); // invalid sequence, move one char back anc recheck\n\n        if (chr < 0xc2 && chr > 0x7f) {\n          curLine = curLine.substr(0, curLine.length - 3);\n          done = false;\n        }\n      }\n    }\n\n    if (curLine.length) {\n      lines.push(curLine);\n    }\n\n    str = str.substr(curLine.length);\n  }\n\n  return lines;\n}\n/**\n *\n * @param {number} nr number\n * @returns {boolean} if number is in range\n */\n\n\nfunction checkRanges(nr) {\n  return RANGES.reduce(function (val, range) {\n    return val || range.length === 1 && nr === range[0] || range.length === 2 && nr >= range[0] && nr <= range[1];\n  }, false);\n}\n/**\n * Encodes all non printable and non ascii bytes to =XX form, where XX is the\n * byte value in hex. This function does not convert linebreaks etc. it\n * only escapes character sequences\n *\n * NOTE: Encoding support depends on util.TextDecoder, which is severely limited\n * prior to Node.js 13.\n *\n * @see https://nodejs.org/api/util.html#util_whatwg_supported_encodings\n * @see https://github.com/nodejs/node/issues/19214\n *\n * @param {string|Uint8Array} data Either a string or an Uint8Array\n * @param {string} encoding WHATWG supported encoding\n * @return {string} Mime encoded string\n */\n\n\nfunction mimeEncode() {\n  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'utf-8';\n  var decoder = new TextDecoder(encoding);\n  var buffer = typeof data === 'string' ? encoder.encode(data) : encoder.encode(decoder.decode(data));\n  return buffer.reduce(function (aggregate, ord, index) {\n    return checkRanges(ord) && !((ord === 0x20 || ord === 0x09) && (index === buffer.length - 1 || buffer[index + 1] === 0x0a || buffer[index + 1] === 0x0d)) ? // if the char is in allowed range, then keep as is, unless it is a ws in the end of a line\n    aggregate + String.fromCharCode(ord) : \"\".concat(aggregate, \"=\").concat(ord < 0x10 ? '0' : '').concat(ord.toString(16).toUpperCase());\n  }, '');\n}\n/**\n * Encodes a string or an Uint8Array to an UTF-8 MIME Word\n *\n * NOTE: Encoding support depends on util.TextDecoder, which is severely limited\n * prior to Node.js 13.\n *\n * @see https://tools.ietf.org/html/rfc2047\n * @see https://nodejs.org/api/util.html#util_whatwg_supported_encodings\n * @see https://github.com/nodejs/node/issues/19214\n *\n * @param {string|Uint8Array} data String to be encoded\n * @param {'Q' | 'B'} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n * @param {string} encoding WHATWG supported encoding\n * @return {string} Single or several mime words joined together\n */\n\n\nfunction mimeWordEncode(data) {\n  var mimeWordEncoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Q';\n  var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'utf-8';\n  var parts = [];\n  var decoder = new TextDecoder(encoding);\n  var str = typeof data === 'string' ? data : decoder.decode(data);\n\n  if (mimeWordEncoding === 'Q') {\n    var encodedStr = mimeEncode(str, encoding).replace(/[^a-z0-9!*+\\-/=]/gi, function (chr) {\n      return chr === ' ' ? '_' : '=' + (chr.charCodeAt(0) < 0x10 ? '0' : '') + chr.charCodeAt(0).toString(16).toUpperCase();\n    });\n    parts = encodedStr.length < MAX_MIME_WORD_LENGTH ? [encodedStr] : splitMimeEncodedString(encodedStr, MAX_MIME_WORD_LENGTH);\n  } else {\n    // Fits as much as possible into every line without breaking utf-8 multibyte characters' octets up across lines\n    var j = 0;\n    var i = 0;\n\n    while (i < str.length) {\n      if (encoder.encode(str.substring(j, i)).length > MAX_B64_MIME_WORD_BYTE_LENGTH) {\n        // we went one character too far, substring at the char before\n        parts.push(str.substring(j, i - 1));\n        j = i - 1;\n      } else {\n        i++;\n      }\n    } // add the remainder of the string\n\n\n    str.substring(j) && parts.push(str.substring(j));\n    parts = parts.map(function (x) {\n      return encoder.encode(x);\n    }).map(function (x) {\n      return encodeBase64(x);\n    });\n  }\n\n  return parts.map(function (p) {\n    return \"=?UTF-8?\".concat(mimeWordEncoding, \"?\").concat(p, \"?= \");\n  }).join('').trim();\n}\n\nvar CRLF$1 = '\\r\\n';\n/**\n * MIME standard wants 76 char chunks when sending out.\n */\n\nvar MIMECHUNK = 76;\n/**\n * meets both base64 and mime divisibility\n */\n\nvar MIME64CHUNK = MIMECHUNK * 6;\n/**\n * size of the message stream buffer\n */\n\nvar BUFFERSIZE = MIMECHUNK * 24 * 7;\nvar counter = 0;\n\nfunction generateBoundary() {\n  var text = '';\n  var possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'()+_,-./:=?\";\n\n  for (var i = 0; i < 69; i++) {\n    text += possible.charAt(Math.floor(Math.random() * possible.length));\n  }\n\n  return text;\n}\n\nfunction convertPersonToAddress(person) {\n  return addressparser(person).map(function (_ref) {\n    var name = _ref.name,\n        address = _ref.address;\n    return name ? \"\".concat(mimeWordEncode(name).replace(/,/g, '=2C'), \" <\").concat(address, \">\") : address;\n  }).join(', ');\n}\n\nfunction convertDashDelimitedTextToSnakeCase(text) {\n  return text.toLowerCase().replace(/^(.)|-(.)/g, function (match) {\n    return match.toUpperCase();\n  });\n}\n\nvar Message = /*#__PURE__*/function () {\n  /**\n   * Construct an rfc2822-compliant message object.\n   *\n   * Special notes:\n   * - The `from` field is required.\n   * - At least one `to`, `cc`, or `bcc` header is also required.\n   * - You can also add whatever other headers you want.\n   *\n   * @see https://tools.ietf.org/html/rfc2822\n   * @param {Partial<MessageHeaders>} headers Message headers\n   */\n  function Message(headers) {\n    _classCallCheck(this, Message);\n\n    this.attachments = [];\n    this.header = {\n      'message-id': \"<\".concat(new Date().getTime(), \".\").concat(counter++, \".\").concat(process.pid, \"@\").concat(hostname(), \">\"),\n      date: getRFC2822Date()\n    };\n    this.content = 'text/plain; charset=utf-8';\n    this.alternative = null;\n\n    for (var header in headers) {\n      // allow user to override default content-type to override charset or send a single non-text message\n      if (/^content-type$/i.test(header)) {\n        this.content = headers[header];\n      } else if (header === 'text') {\n        this.text = headers[header];\n      } else if (header === 'attachment' && typeof headers[header] === 'object') {\n        var attachment = headers[header];\n\n        if (Array.isArray(attachment)) {\n          for (var i = 0; i < attachment.length; i++) {\n            this.attach(attachment[i]);\n          }\n        } else if (attachment != null) {\n          this.attach(attachment);\n        }\n      } else if (header === 'subject') {\n        this.header.subject = mimeWordEncode(headers.subject);\n      } else if (/^(cc|bcc|to|from)/i.test(header)) {\n        this.header[header.toLowerCase()] = convertPersonToAddress(headers[header]);\n      } else {\n        // allow any headers the user wants to set??\n        this.header[header.toLowerCase()] = headers[header];\n      }\n    }\n  }\n  /**\n   * Attach a file to the message.\n   *\n   * Can be called multiple times, each adding a new attachment.\n   *\n   * @public\n   * @param {MessageAttachment} options attachment options\n   * @returns {Message} the current instance for chaining\n   */\n\n\n  _createClass(Message, [{\n    key: \"attach\",\n    value: function attach(options) {\n      // sender can specify an attachment as an alternative\n      if (options.alternative) {\n        this.alternative = options;\n        this.alternative.charset = options.charset || 'utf-8';\n        this.alternative.type = options.type || 'text/html';\n        this.alternative.inline = true;\n      } else {\n        this.attachments.push(options);\n      }\n\n      return this;\n    }\n    /**\n     * @public\n     * @returns {{ isValid: boolean, validationError: (string | undefined) }} an object specifying whether this message is validly formatted, and the first validation error if it is not.\n     */\n\n  }, {\n    key: \"checkValidity\",\n    value: function checkValidity() {\n      if (typeof this.header.from !== 'string' && Array.isArray(this.header.from) === false) {\n        return {\n          isValid: false,\n          validationError: 'Message must have a `from` header'\n        };\n      }\n\n      if (typeof this.header.to !== 'string' && Array.isArray(this.header.to) === false && typeof this.header.cc !== 'string' && Array.isArray(this.header.cc) === false && typeof this.header.bcc !== 'string' && Array.isArray(this.header.bcc) === false) {\n        return {\n          isValid: false,\n          validationError: 'Message must have at least one `to`, `cc`, or `bcc` header'\n        };\n      }\n\n      if (this.attachments.length > 0) {\n        var failed = [];\n        this.attachments.forEach(function (attachment) {\n          if (attachment.path) {\n            if (existsSync(attachment.path) === false) {\n              failed.push(\"\".concat(attachment.path, \" does not exist\"));\n            }\n          } else if (attachment.stream) {\n            if (!attachment.stream.readable) {\n              failed.push('attachment stream is not readable');\n            }\n          } else if (!attachment.data) {\n            failed.push('attachment has no data associated with it');\n          }\n        });\n        return {\n          isValid: failed.length === 0,\n          validationError: failed.join(', ')\n        };\n      }\n\n      return {\n        isValid: true,\n        validationError: undefined\n      };\n    }\n    /**\n     * @public\n     * @deprecated does not conform to the `errback` style followed by the rest of the library, and will be removed in the next major version. use `checkValidity` instead.\n     * @param {function(isValid: boolean, invalidReason: (string | undefined)): void} callback .\n     * @returns {void}\n     */\n\n  }, {\n    key: \"valid\",\n    value: function valid(callback) {\n      var _this$checkValidity = this.checkValidity(),\n          isValid = _this$checkValidity.isValid,\n          validationError = _this$checkValidity.validationError;\n\n      callback(isValid, validationError);\n    }\n    /**\n     * @public\n     * @returns {MessageStream} a stream of the current message\n     */\n\n  }, {\n    key: \"stream\",\n    value: function stream() {\n      return new MessageStream(this);\n    }\n    /**\n     * @public\n     * @param {function(Error, string): void} callback the function to call with the error and buffer\n     * @returns {void}\n     */\n\n  }, {\n    key: \"read\",\n    value: function read(callback) {\n      var buffer = '';\n      var str = this.stream();\n      str.on('data', function (data) {\n        return buffer += data;\n      });\n      str.on('end', function (err) {\n        return callback(err, buffer);\n      });\n      str.on('error', function (err) {\n        return callback(err, buffer);\n      });\n    }\n  }, {\n    key: \"readAsync\",\n    value: function readAsync() {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        _this.read(function (err, buffer) {\n          if (err != null) {\n            reject(err);\n          } else {\n            resolve(buffer);\n          }\n        });\n      });\n    }\n  }]);\n\n  return Message;\n}();\n\nvar MessageStream = /*#__PURE__*/function (_Stream) {\n  _inherits(MessageStream, _Stream);\n\n  var _super = _createSuper(MessageStream);\n\n  /**\n   * @param {Message} message the message to stream\n   */\n  function MessageStream(message) {\n    var _this2;\n\n    _classCallCheck(this, MessageStream);\n\n    _this2 = _super.call(this);\n    _this2.message = message;\n    _this2.readable = true;\n    _this2.paused = false;\n    _this2.buffer = Buffer.alloc(MIMECHUNK * 24 * 7);\n    _this2.bufferIndex = 0;\n    /**\n     * @param {string} [data] the data to output\n     * @param {Function} [callback] the function\n     * @param {any[]} [args] array of arguments to pass to the callback\n     * @returns {void}\n     */\n\n    var output = function output(data) {\n      // can we buffer the data?\n      if (_this2.buffer != null) {\n        var bytes = Buffer.byteLength(data);\n\n        if (bytes + _this2.bufferIndex < _this2.buffer.length) {\n          _this2.buffer.write(data, _this2.bufferIndex);\n\n          _this2.bufferIndex += bytes;\n        } // we can't buffer the data, so ship it out!\n        else if (bytes > _this2.buffer.length) {\n          if (_this2.bufferIndex) {\n            _this2.emit('data', _this2.buffer.toString('utf-8', 0, _this2.bufferIndex));\n\n            _this2.bufferIndex = 0;\n          }\n\n          var loops = Math.ceil(data.length / _this2.buffer.length);\n          var loop = 0;\n\n          while (loop < loops) {\n            _this2.emit('data', data.substring(_this2.buffer.length * loop, _this2.buffer.length * (loop + 1)));\n\n            loop++;\n          }\n        } // we need to clean out the buffer, it is getting full\n        else {\n          if (!_this2.paused) {\n            _this2.emit('data', _this2.buffer.toString('utf-8', 0, _this2.bufferIndex));\n\n            _this2.buffer.write(data, 0);\n\n            _this2.bufferIndex = bytes;\n          } else {\n            // we can't empty out the buffer, so let's wait till we resume before adding to it\n            _this2.once('resume', function () {\n              return output(data);\n            });\n          }\n        }\n      }\n    };\n    /**\n     * @param {MessageAttachment} [attachment] the attachment whose headers you would like to output\n     * @returns {void}\n     */\n\n\n    var outputAttachmentHeaders = function outputAttachmentHeaders(attachment) {\n      var data = [];\n      var headers = {\n        'content-type': attachment.type + (attachment.charset ? \"; charset=\".concat(attachment.charset) : '') + (attachment.method ? \"; method=\".concat(attachment.method) : ''),\n        'content-transfer-encoding': 'base64',\n        'content-disposition': attachment.inline ? 'inline' : \"attachment; filename=\\\"\".concat(mimeWordEncode(attachment.name), \"\\\"\")\n      }; // allow sender to override default headers\n\n      if (attachment.headers != null) {\n        for (var header in attachment.headers) {\n          headers[header.toLowerCase()] = attachment.headers[header];\n        }\n      }\n\n      for (var _header in headers) {\n        data = data.concat([convertDashDelimitedTextToSnakeCase(_header), ': ', headers[_header], CRLF$1]);\n      }\n\n      output(data.concat([CRLF$1]).join(''));\n    };\n    /**\n     * @param {string} data the data to output as base64\n     * @param {function(): void} [callback] the function to call after output is finished\n     * @returns {void}\n     */\n\n\n    var outputBase64 = function outputBase64(data, callback) {\n      var loops = Math.ceil(data.length / MIMECHUNK);\n      var loop = 0;\n\n      while (loop < loops) {\n        output(data.substring(MIMECHUNK * loop, MIMECHUNK * (loop + 1)) + CRLF$1);\n        loop++;\n      }\n\n      if (callback) {\n        callback();\n      }\n    };\n\n    var outputFile = function outputFile(attachment, next) {\n      var _a;\n\n      var chunk = MIME64CHUNK * 16;\n      var buffer = Buffer.alloc(chunk);\n      var inputEncoding = ((_a = attachment === null || attachment === void 0 ? void 0 : attachment.headers) === null || _a === void 0 ? void 0 : _a['content-transfer-encoding']) || 'base64';\n      var encoding = inputEncoding === '7bit' ? 'ascii' : inputEncoding === '8bit' ? 'binary' : inputEncoding;\n      /**\n       * @param {Error} err the error to emit\n       * @param {number} fd the file descriptor\n       * @returns {void}\n       */\n\n      var opened = function opened(err, fd) {\n        if (err) {\n          _this2.emit('error', err);\n\n          return;\n        }\n\n        var readBytes = function readBytes(err, bytes) {\n          if (err || _this2.readable === false) {\n            _this2.emit('error', err || new Error('message stream was interrupted somehow!'));\n\n            return;\n          } // guaranteed to be encoded without padding unless it is our last read\n\n\n          outputBase64(buffer.toString(encoding, 0, bytes), function () {\n            if (bytes == chunk) {\n              // we read a full chunk, there might be more\n              read(fd, buffer, 0, chunk, null, readBytes);\n            } // that was the last chunk, we are done reading the file\n            else {\n              _this2.removeListener('error', closeSync);\n\n              close(fd, next);\n            }\n          });\n        };\n\n        read(fd, buffer, 0, chunk, null, readBytes);\n\n        _this2.once('error', closeSync);\n      };\n\n      open(attachment.path, 'r', opened);\n    };\n    /**\n     * @param {MessageAttachment} attachment the metadata to use as headers\n     * @param {function(): void} callback the function to call after output is finished\n     * @returns {void}\n     */\n\n\n    var outputStream = function outputStream(attachment, callback) {\n      var stream = attachment.stream;\n\n      if (stream === null || stream === void 0 ? void 0 : stream.readable) {\n        var previous = Buffer.alloc(0);\n        stream.resume();\n        stream.on('end', function () {\n          outputBase64(previous.toString('base64'), callback);\n\n          _this2.removeListener('pause', stream.pause);\n\n          _this2.removeListener('resume', stream.resume);\n\n          _this2.removeListener('error', stream.resume);\n        });\n        stream.on('data', function (buff) {\n          // do we have bytes from a previous stream data event?\n          var buffer = Buffer.isBuffer(buff) ? buff : Buffer.from(buff);\n\n          if (previous.byteLength > 0) {\n            buffer = Buffer.concat([previous, buffer]);\n          }\n\n          var padded = buffer.length % MIME64CHUNK;\n          previous = Buffer.alloc(padded); // encode as much of the buffer to base64 without empty bytes\n\n          if (padded > 0) {\n            // copy dangling bytes into previous buffer\n            buffer.copy(previous, 0, buffer.length - padded);\n          }\n\n          outputBase64(buffer.toString('base64', 0, buffer.length - padded));\n        });\n\n        _this2.on('pause', stream.pause);\n\n        _this2.on('resume', stream.resume);\n\n        _this2.on('error', stream.resume);\n      } else {\n        _this2.emit('error', {\n          message: 'stream not readable'\n        });\n      }\n    };\n\n    var outputAttachment = function outputAttachment(attachment, callback) {\n      var build = attachment.path ? outputFile : attachment.stream ? outputStream : outputData;\n      outputAttachmentHeaders(attachment);\n      build(attachment, callback);\n    };\n    /**\n     * @param {string} boundary the boundary text between outputs\n     * @param {MessageAttachment[]} list the list of potential messages to output\n     * @param {number} index the index of the list item to output\n     * @param {function(): void} callback the function to call if index is greater than upper bound\n     * @returns {void}\n     */\n\n\n    var outputMessage = function outputMessage(boundary, list, index, callback) {\n      if (index < list.length) {\n        output(\"--\".concat(boundary).concat(CRLF$1));\n\n        if (list[index].related) {\n          outputRelated(list[index], function () {\n            return outputMessage(boundary, list, index + 1, callback);\n          });\n        } else {\n          outputAttachment(list[index], function () {\n            return outputMessage(boundary, list, index + 1, callback);\n          });\n        }\n      } else {\n        output(\"\".concat(CRLF$1, \"--\").concat(boundary, \"--\").concat(CRLF$1).concat(CRLF$1));\n        callback();\n      }\n    };\n\n    var outputMixed = function outputMixed() {\n      var boundary = generateBoundary();\n      output(\"Content-Type: multipart/mixed; boundary=\\\"\".concat(boundary, \"\\\"\").concat(CRLF$1).concat(CRLF$1, \"--\").concat(boundary).concat(CRLF$1));\n\n      if (_this2.message.alternative == null) {\n        outputText(_this2.message);\n        outputMessage(boundary, _this2.message.attachments, 0, close$1);\n      } else {\n        outputAlternative( // typescript bug; should narrow to { alternative: MessageAttachment }\n        _this2.message, function () {\n          return outputMessage(boundary, _this2.message.attachments, 0, close$1);\n        });\n      }\n    };\n    /**\n     * @param {MessageAttachment} attachment the metadata to use as headers\n     * @param {function(): void} callback the function to call after output is finished\n     * @returns {void}\n     */\n\n\n    var outputData = function outputData(attachment, callback) {\n      var _a, _b;\n\n      outputBase64(attachment.encoded ? (_a = attachment.data) !== null && _a !== void 0 ? _a : '' : Buffer.from((_b = attachment.data) !== null && _b !== void 0 ? _b : '').toString('base64'), callback);\n    };\n    /**\n     * @param {Message} message the message to output\n     * @returns {void}\n     */\n\n\n    var outputText = function outputText(message) {\n      var data = [];\n      data = data.concat(['Content-Type:', message.content, CRLF$1, 'Content-Transfer-Encoding: 7bit', CRLF$1]);\n      data = data.concat(['Content-Disposition: inline', CRLF$1, CRLF$1]);\n      data = data.concat([message.text || '', CRLF$1, CRLF$1]);\n      output(data.join(''));\n    };\n    /**\n     * @param {MessageAttachment} message the message to output\n     * @param {function(): void} callback the function to call after output is finished\n     * @returns {void}\n     */\n\n\n    var outputRelated = function outputRelated(message, callback) {\n      var boundary = generateBoundary();\n      output(\"Content-Type: multipart/related; boundary=\\\"\".concat(boundary, \"\\\"\").concat(CRLF$1).concat(CRLF$1, \"--\").concat(boundary).concat(CRLF$1));\n      outputAttachment(message, function () {\n        var _a;\n\n        outputMessage(boundary, (_a = message.related) !== null && _a !== void 0 ? _a : [], 0, function () {\n          output(\"\".concat(CRLF$1, \"--\").concat(boundary, \"--\").concat(CRLF$1).concat(CRLF$1));\n          callback();\n        });\n      });\n    };\n    /**\n     * @param {Message} message the message to output\n     * @param {function(): void} callback the function to call after output is finished\n     * @returns {void}\n     */\n\n\n    var outputAlternative = function outputAlternative(message, callback) {\n      var boundary = generateBoundary();\n      output(\"Content-Type: multipart/alternative; boundary=\\\"\".concat(boundary, \"\\\"\").concat(CRLF$1).concat(CRLF$1, \"--\").concat(boundary).concat(CRLF$1));\n      outputText(message);\n      output(\"--\".concat(boundary).concat(CRLF$1));\n      /**\n       * @returns {void}\n       */\n\n      var finish = function finish() {\n        output([CRLF$1, '--', boundary, '--', CRLF$1, CRLF$1].join(''));\n        callback();\n      };\n\n      if (message.alternative.related) {\n        outputRelated(message.alternative, finish);\n      } else {\n        outputAttachment(message.alternative, finish);\n      }\n    };\n\n    var close$1 = function close$1(err) {\n      var _a, _b;\n\n      if (err) {\n        _this2.emit('error', err);\n      } else {\n        _this2.emit('data', (_b = (_a = _this2.buffer) === null || _a === void 0 ? void 0 : _a.toString('utf-8', 0, _this2.bufferIndex)) !== null && _b !== void 0 ? _b : '');\n\n        _this2.emit('end');\n      }\n\n      _this2.buffer = null;\n      _this2.bufferIndex = 0;\n      _this2.readable = false;\n\n      _this2.removeAllListeners('resume');\n\n      _this2.removeAllListeners('pause');\n\n      _this2.removeAllListeners('error');\n\n      _this2.removeAllListeners('data');\n\n      _this2.removeAllListeners('end');\n    };\n    /**\n     * @returns {void}\n     */\n\n\n    var outputHeaderData = function outputHeaderData() {\n      if (_this2.message.attachments.length || _this2.message.alternative) {\n        output(\"MIME-Version: 1.0\".concat(CRLF$1));\n        outputMixed();\n      } // you only have a text message!\n      else {\n        outputText(_this2.message);\n        close$1();\n      }\n    };\n    /**\n     * @returns {void}\n     */\n\n\n    var outputHeader = function outputHeader() {\n      var data = [];\n\n      for (var header in _this2.message.header) {\n        // do not output BCC in the headers (regex) nor custom Object.prototype functions...\n        if (!/bcc/i.test(header) && Object.prototype.hasOwnProperty.call(_this2.message.header, header)) {\n          data = data.concat([convertDashDelimitedTextToSnakeCase(header), ': ', _this2.message.header[header], CRLF$1]);\n        }\n      }\n\n      output(data.join(''));\n      outputHeaderData();\n    };\n\n    _this2.once('destroy', close$1);\n\n    process.nextTick(outputHeader);\n    return _this2;\n  }\n  /**\n   * @public\n   * pause the stream\n   * @returns {void}\n   */\n\n\n  _createClass(MessageStream, [{\n    key: \"pause\",\n    value: function pause() {\n      this.paused = true;\n      this.emit('pause');\n    }\n    /**\n     * @public\n     * resume the stream\n     * @returns {void}\n     */\n\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      this.paused = false;\n      this.emit('resume');\n    }\n    /**\n     * @public\n     * destroy the stream\n     * @returns {void}\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.emit('destroy', this.bufferIndex > 0 ? {\n        message: 'message stream destroyed'\n      } : null);\n    }\n    /**\n     * @public\n     * destroy the stream at first opportunity\n     * @returns {void}\n     */\n\n  }, {\n    key: \"destroySoon\",\n    value: function destroySoon() {\n      this.emit('destroy');\n    }\n  }]);\n\n  return MessageStream;\n}(Stream);\n/**\n * @readonly\n * @enum\n */\n\n\nvar SMTPErrorStates = {\n  COULDNOTCONNECT: 1,\n  BADRESPONSE: 2,\n  AUTHFAILED: 3,\n  TIMEDOUT: 4,\n  ERROR: 5,\n  NOCONNECTION: 6,\n  AUTHNOTSUPPORTED: 7,\n  CONNECTIONCLOSED: 8,\n  CONNECTIONENDED: 9,\n  CONNECTIONAUTH: 10\n};\n\nvar SMTPError = /*#__PURE__*/function (_Error) {\n  _inherits(SMTPError, _Error);\n\n  var _super2 = _createSuper(SMTPError);\n\n  /**\n   * @protected\n   * @param {string} message error message\n   */\n  function SMTPError(message) {\n    var _this3;\n\n    _classCallCheck(this, SMTPError);\n\n    _this3 = _super2.call(this, message);\n    _this3.code = null;\n    _this3.smtp = null;\n    _this3.previous = null;\n    return _this3;\n  }\n  /**\n   *\n   * @param {string} message error message\n   * @param {number} code smtp error state\n   * @param {Error | null} error previous error\n   * @param {unknown} smtp arbitrary data\n   * @returns {SMTPError} error\n   */\n\n\n  _createClass(SMTPError, null, [{\n    key: \"create\",\n    value: function create(message, code, error, smtp) {\n      var msg = (error === null || error === void 0 ? void 0 : error.message) ? \"\".concat(message, \" (\").concat(error.message, \")\") : message;\n      var err = new SMTPError(msg);\n      err.code = code;\n      err.smtp = smtp;\n\n      if (error) {\n        err.previous = error;\n      }\n\n      return err;\n    }\n  }]);\n\n  return SMTPError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar SMTPResponseMonitor = /*#__PURE__*/_createClass(function SMTPResponseMonitor(stream, timeout, onerror) {\n  _classCallCheck(this, SMTPResponseMonitor);\n\n  var buffer = '';\n\n  var notify = function notify() {\n    var _a, _b;\n\n    if (buffer.length) {\n      // parse buffer for response codes\n      var line = buffer.replace('\\r', '');\n\n      if (!((_b = (_a = line.trim().split(/\\n/).pop()) === null || _a === void 0 ? void 0 : _a.match(/^(\\d{3})\\s/)) !== null && _b !== void 0 ? _b : false)) {\n        return;\n      }\n\n      var match = line ? line.match(/(\\d+)\\s?(.*)/) : null;\n      var data = match !== null ? {\n        code: match[1],\n        message: match[2],\n        data: line\n      } : {\n        code: -1,\n        data: line\n      };\n      stream.emit('response', null, data);\n      buffer = '';\n    }\n  };\n\n  var error = function error(err) {\n    stream.emit('response', SMTPError.create('connection encountered an error', SMTPErrorStates.ERROR, err));\n  };\n\n  var timedout = function timedout(err) {\n    stream.end();\n    stream.emit('response', SMTPError.create('timedout while connecting to smtp server', SMTPErrorStates.TIMEDOUT, err));\n  };\n\n  var watch = function watch(data) {\n    if (data !== null) {\n      buffer += data.toString();\n      notify();\n    }\n  };\n\n  var close = function close(err) {\n    stream.emit('response', SMTPError.create('connection has closed', SMTPErrorStates.CONNECTIONCLOSED, err));\n  };\n\n  var end = function end(err) {\n    stream.emit('response', SMTPError.create('connection has ended', SMTPErrorStates.CONNECTIONENDED, err));\n  };\n\n  this.stop = function (err) {\n    stream.removeAllListeners('response');\n    stream.removeListener('data', watch);\n    stream.removeListener('end', end);\n    stream.removeListener('close', close);\n    stream.removeListener('error', error);\n\n    if (err != null && typeof onerror === 'function') {\n      onerror(err);\n    }\n  };\n\n  stream.on('data', watch);\n  stream.on('end', end);\n  stream.on('close', close);\n  stream.on('error', error);\n  stream.setTimeout(timeout, timedout);\n});\n/**\n * @readonly\n * @enum\n */\n\n\nvar AUTH_METHODS = {\n  PLAIN: 'PLAIN',\n  'CRAM-MD5': 'CRAM-MD5',\n  LOGIN: 'LOGIN',\n  XOAUTH2: 'XOAUTH2'\n};\n/**\n * @readonly\n * @enum\n */\n\nvar SMTPState = {\n  NOTCONNECTED: 0,\n  CONNECTING: 1,\n  CONNECTED: 2\n};\nvar DEFAULT_TIMEOUT = 5000;\nvar SMTP_PORT = 25;\nvar SMTP_SSL_PORT = 465;\nvar SMTP_TLS_PORT = 587;\nvar CRLF = '\\r\\n';\nvar GREYLIST_DELAY = 300;\nvar DEBUG = 0;\n/**\n * @param {...any[]} args the message(s) to log\n * @returns {void}\n */\n\nvar log = function log() {\n  if (DEBUG === 1) {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    args.forEach(function (d) {\n      return console.log(typeof d === 'object' ? d instanceof Error ? d.message : JSON.stringify(d) : d);\n    });\n  }\n};\n/**\n * @param {function(...any[]): void} callback the function to call\n * @param {...any[]} args the arguments to apply to the function\n * @returns {void}\n */\n\n\nvar caller = function caller(callback) {\n  if (typeof callback === 'function') {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    callback.apply(void 0, args);\n  }\n};\n\nvar SMTPConnection = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(SMTPConnection, _EventEmitter);\n\n  var _super3 = _createSuper(SMTPConnection);\n\n  /**\n   * SMTP class written using python's (2.7) smtplib.py as a base.\n   *\n   * To target a Message Transfer Agent (MTA), omit all options.\n   *\n   * NOTE: `host` is trimmed before being used to establish a connection; however, the original untrimmed value will still be visible in configuration.\n   */\n  function SMTPConnection() {\n    var _this4;\n\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        timeout = _ref2.timeout,\n        host = _ref2.host,\n        user = _ref2.user,\n        password = _ref2.password,\n        domain = _ref2.domain,\n        port = _ref2.port,\n        ssl = _ref2.ssl,\n        tls = _ref2.tls,\n        logger = _ref2.logger,\n        authentication = _ref2.authentication;\n\n    _classCallCheck(this, SMTPConnection);\n\n    var _a;\n\n    _this4 = _super3.call(this);\n    _this4.timeout = DEFAULT_TIMEOUT;\n    _this4.log = log;\n    _this4.authentication = [AUTH_METHODS['CRAM-MD5'], AUTH_METHODS.LOGIN, AUTH_METHODS.PLAIN, AUTH_METHODS.XOAUTH2];\n    _this4._state = SMTPState.NOTCONNECTED;\n    _this4._secure = false;\n    _this4.loggedin = false;\n    _this4.sock = null;\n    _this4.features = null;\n    _this4.monitor = null;\n    _this4.domain = hostname();\n    _this4.host = 'localhost';\n    _this4.ssl = false;\n    _this4.tls = false;\n    _this4.greylistResponseTracker = new WeakSet();\n\n    if (Array.isArray(authentication)) {\n      _this4.authentication = authentication;\n    }\n\n    if (typeof timeout === 'number') {\n      _this4.timeout = timeout;\n    }\n\n    if (typeof domain === 'string') {\n      _this4.domain = domain;\n    }\n\n    if (typeof host === 'string') {\n      _this4.host = host;\n    }\n\n    if (ssl != null && (typeof ssl === 'boolean' || typeof ssl === 'object' && Array.isArray(ssl) === false)) {\n      _this4.ssl = ssl;\n    }\n\n    if (tls != null && (typeof tls === 'boolean' || typeof tls === 'object' && Array.isArray(tls) === false)) {\n      _this4.tls = tls;\n    }\n\n    _this4.port = port || (ssl ? SMTP_SSL_PORT : tls ? SMTP_TLS_PORT : SMTP_PORT);\n    _this4.loggedin = user && password ? false : true;\n\n    if (!user && ((_a = password === null || password === void 0 ? void 0 : password.length) !== null && _a !== void 0 ? _a : 0) > 0) {\n      throw new Error('`password` cannot be set without `user`');\n    } // keep these strings hidden when quicky debugging/logging\n\n\n    _this4.user = function () {\n      return user;\n    };\n\n    _this4.password = function () {\n      return password;\n    };\n\n    if (typeof logger === 'function') {\n      _this4.log = logger;\n    }\n\n    return _this4;\n  }\n  /**\n   * @public\n   * @param {0 | 1} level -\n   * @returns {void}\n   */\n\n\n  _createClass(SMTPConnection, [{\n    key: \"debug\",\n    value: function debug(level) {\n      DEBUG = level;\n    }\n    /**\n     * @public\n     * @returns {SMTPState} the current state\n     */\n\n  }, {\n    key: \"state\",\n    value: function state() {\n      return this._state;\n    }\n    /**\n     * @public\n     * @returns {boolean} whether or not the instance is authorized\n     */\n\n  }, {\n    key: \"authorized\",\n    value: function authorized() {\n      return this.loggedin;\n    }\n    /**\n     * Establish an SMTP connection.\n     *\n     * NOTE: `host` is trimmed before being used to establish a connection; however, the original untrimmed value will still be visible in configuration.\n     *\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {number} [port] the port to use for the connection\n     * @param {string} [host] the hostname to use for the connection\n     * @param {ConnectOptions} [options={}] the options\n     * @returns {void}\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect(callback) {\n      var _this5 = this;\n\n      var port = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.port;\n      var host = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.host;\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      this.port = port;\n      this.host = host;\n      this.ssl = options.ssl || this.ssl;\n\n      if (this._state !== SMTPState.NOTCONNECTED) {\n        this.quit(function () {\n          return _this5.connect(callback, port, host, options);\n        });\n      }\n      /**\n       * @returns {void}\n       */\n\n\n      var connected = function connected() {\n        _this5.log(\"connected: \".concat(_this5.host, \":\").concat(_this5.port));\n\n        if (_this5.ssl && !_this5.tls) {\n          // if key/ca/cert was passed in, check if connection is authorized\n          if (typeof _this5.ssl !== 'boolean' && _this5.sock instanceof TLSSocket && !_this5.sock.authorized) {\n            _this5.close(true);\n\n            caller(callback, SMTPError.create('could not establish an ssl connection', SMTPErrorStates.CONNECTIONAUTH));\n          } else {\n            _this5._secure = true;\n          }\n        }\n      };\n      /**\n       * @param {Error} err err\n       * @returns {void}\n       */\n\n\n      var connectedErrBack = function connectedErrBack(err) {\n        if (!err) {\n          connected();\n        } else {\n          _this5.close(true);\n\n          _this5.log(err);\n\n          caller(callback, SMTPError.create('could not connect', SMTPErrorStates.COULDNOTCONNECT, err));\n        }\n      };\n\n      var response = function response(err, msg) {\n        if (err) {\n          if (_this5._state === SMTPState.NOTCONNECTED && !_this5.sock) {\n            return;\n          }\n\n          _this5.close(true);\n\n          caller(callback, err);\n        } else if (msg.code == '220') {\n          _this5.log(msg.data); // might happen first, so no need to wait on connected()\n\n\n          _this5._state = SMTPState.CONNECTED;\n          caller(callback, null, msg.data);\n        } else {\n          _this5.log(\"response (data): \".concat(msg.data));\n\n          _this5.quit(function () {\n            caller(callback, SMTPError.create('bad response on connection', SMTPErrorStates.BADRESPONSE, err, msg.data));\n          });\n        }\n      };\n\n      this._state = SMTPState.CONNECTING;\n      this.log(\"connecting: \".concat(this.host, \":\").concat(this.port));\n\n      if (this.ssl) {\n        this.sock = _connect(this.port, this.host.trim(), typeof this.ssl === 'object' ? this.ssl : {}, connected);\n      } else {\n        this.sock = new Socket();\n        this.sock.connect(this.port, this.host.trim(), connectedErrBack);\n      }\n\n      this.monitor = new SMTPResponseMonitor(this.sock, this.timeout, function () {\n        return _this5.close(true);\n      });\n      this.sock.once('response', response);\n      this.sock.once('error', response); // the socket could reset or throw, so let's handle it and let the user know\n    }\n    /**\n     * @public\n     * @param {string} str the string to send\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(str, callback) {\n      var _this6 = this;\n\n      if (this.sock != null && this._state === SMTPState.CONNECTED) {\n        this.log(str);\n        this.sock.once('response', function (err, msg) {\n          if (err) {\n            caller(callback, err);\n          } else {\n            _this6.log(msg.data);\n\n            caller(callback, null, msg);\n          }\n        });\n\n        if (this.sock.writable) {\n          this.sock.write(str);\n        }\n      } else {\n        this.close(true);\n        caller(callback, SMTPError.create('no connection has been established', SMTPErrorStates.NOCONNECTION));\n      }\n    }\n    /**\n     * @public\n     * @param {string} cmd command to issue\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {(number[] | number)} [codes=[250]] array codes\n     * @returns {void}\n     */\n\n  }, {\n    key: \"command\",\n    value: function command(cmd, callback) {\n      var _this7 = this;\n\n      var codes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [250];\n      var codesArray = Array.isArray(codes) ? codes : typeof codes === 'number' ? [codes] : [250];\n\n      var response = function response(err, msg) {\n        if (err) {\n          caller(callback, err);\n        } else {\n          var code = Number(msg.code);\n\n          if (codesArray.indexOf(code) !== -1) {\n            caller(callback, err, msg.data, msg.message);\n          } else if ((code === 450 || code === 451) && msg.message.toLowerCase().includes('greylist') && _this7.greylistResponseTracker.has(response) === false) {\n            _this7.greylistResponseTracker.add(response);\n\n            setTimeout(function () {\n              _this7.send(cmd + CRLF, response);\n            }, GREYLIST_DELAY);\n          } else {\n            var suffix = msg.message ? \": \".concat(msg.message) : '';\n            var errorMessage = \"bad response on command '\".concat(cmd.split(' ')[0], \"'\").concat(suffix);\n            caller(callback, SMTPError.create(errorMessage, SMTPErrorStates.BADRESPONSE, null, msg.data));\n          }\n        }\n      };\n\n      this.greylistResponseTracker.delete(response);\n      this.send(cmd + CRLF, response);\n    }\n    /**\n     * @public\n     * @description SMTP 'helo' command.\n     *\n     * Hostname to send for self command defaults to the FQDN of the local\n     * host.\n     *\n     * As this command was deprecated by rfc2821, it should only be used for compatibility with non-compliant servers.\n     * @see https://tools.ietf.org/html/rfc2821#appendix-F.3\n     *\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {string} domain the domain to associate with the 'helo' request\n     * @returns {void}\n     */\n\n  }, {\n    key: \"helo\",\n    value: function helo(callback, domain) {\n      var _this8 = this;\n\n      this.command(\"helo \".concat(domain || this.domain), function (err, data) {\n        if (err) {\n          caller(callback, err);\n        } else {\n          _this8.parse_smtp_features(data);\n\n          caller(callback, err, data);\n        }\n      });\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n\n  }, {\n    key: \"starttls\",\n    value: function starttls(callback) {\n      var _this9 = this;\n\n      var response = function response(err, msg) {\n        if (_this9.sock == null) {\n          throw new Error('null socket');\n        }\n\n        if (err) {\n          err.message += ' while establishing a starttls session';\n          caller(callback, err);\n        } else {\n          var secureContext = createSecureContext(typeof _this9.tls === 'object' ? _this9.tls : {});\n          var secureSocket = new TLSSocket(_this9.sock, {\n            secureContext: secureContext\n          });\n          secureSocket.on('error', function (err) {\n            _this9.close(true);\n\n            caller(callback, err);\n          });\n          _this9._secure = true;\n          _this9.sock = secureSocket;\n          new SMTPResponseMonitor(_this9.sock, _this9.timeout, function () {\n            return _this9.close(true);\n          });\n          caller(callback, msg.data);\n        }\n      };\n\n      this.command('starttls', response, [220]);\n    }\n    /**\n     * @public\n     * @param {string} data the string to parse for features\n     * @returns {void}\n     */\n\n  }, {\n    key: \"parse_smtp_features\",\n    value: function parse_smtp_features(data) {\n      var _this10 = this;\n\n      //  According to RFC1869 some (badly written)\n      //  MTA's will disconnect on an ehlo. Toss an exception if\n      //  that happens -ddm\n      data.split('\\n').forEach(function (ext) {\n        var parse = ext.match(/^(?:\\d+[-=]?)\\s*?([^\\s]+)(?:\\s+(.*)\\s*?)?$/); // To be able to communicate with as many SMTP servers as possible,\n        // we have to take the old-style auth advertisement into account,\n        // because:\n        // 1) Else our SMTP feature parser gets confused.\n        // 2) There are some servers that only advertise the auth methods we\n        // support using the old style.\n\n        if (parse != null && _this10.features != null) {\n          // RFC 1869 requires a space between ehlo keyword and parameters.\n          // It's actually stricter, in that only spaces are allowed between\n          // parameters, but were not going to check for that here.  Note\n          // that the space isn't present if there are no parameters.\n          _this10.features[parse[1].toLowerCase()] = parse[2] || true;\n        }\n      });\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {string} domain the domain to associate with the 'ehlo' request\n     * @returns {void}\n     */\n\n  }, {\n    key: \"ehlo\",\n    value: function ehlo(callback, domain) {\n      var _this11 = this;\n\n      this.features = {};\n      this.command(\"ehlo \".concat(domain || this.domain), function (err, data) {\n        if (err) {\n          caller(callback, err);\n        } else {\n          _this11.parse_smtp_features(data);\n\n          if (_this11.tls && !_this11._secure) {\n            _this11.starttls(function () {\n              return _this11.ehlo(callback, domain);\n            });\n          } else {\n            caller(callback, err, data);\n          }\n        }\n      });\n    }\n    /**\n     * @public\n     * @param {string} opt the features keyname to check\n     * @returns {boolean} whether the extension exists\n     */\n\n  }, {\n    key: \"has_extn\",\n    value: function has_extn(opt) {\n      var _a;\n\n      return ((_a = this.features) !== null && _a !== void 0 ? _a : {})[opt.toLowerCase()] === undefined;\n    }\n    /**\n     * @public\n     * @description SMTP 'help' command, returns text from the server\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {string} domain the domain to associate with the 'help' request\n     * @returns {void}\n     */\n\n  }, {\n    key: \"help\",\n    value: function help(callback, domain) {\n      this.command(domain ? \"help \".concat(domain) : 'help', callback, [211, 214]);\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n\n  }, {\n    key: \"rset\",\n    value: function rset(callback) {\n      this.command('rset', callback);\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n\n  }, {\n    key: \"noop\",\n    value: function noop(callback) {\n      this.send('noop', callback);\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {string} from the sender\n     * @returns {void}\n     */\n\n  }, {\n    key: \"mail\",\n    value: function mail(callback, from) {\n      this.command(\"mail FROM:\".concat(from), callback);\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {string} to the receiver\n     * @returns {void}\n     */\n\n  }, {\n    key: \"rcpt\",\n    value: function rcpt(callback, to) {\n      this.command(\"RCPT TO:\".concat(to), callback, [250, 251]);\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n\n  }, {\n    key: \"data\",\n    value: function data(callback) {\n      this.command('data', callback, [354]);\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n\n  }, {\n    key: \"data_end\",\n    value: function data_end(callback) {\n      this.command(\"\".concat(CRLF, \".\"), callback);\n    }\n    /**\n     * @public\n     * @param {string} data the message to send\n     * @returns {void}\n     */\n\n  }, {\n    key: \"message\",\n    value: function message(data) {\n      var _a, _b;\n\n      this.log(data);\n      (_b = (_a = this.sock) === null || _a === void 0 ? void 0 : _a.write(data)) !== null && _b !== void 0 ? _b : this.log('no socket to write to');\n    }\n    /**\n     * @public\n     * @description SMTP 'verify' command -- checks for address validity.\n     * @param {string} address the address to validate\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n\n  }, {\n    key: \"verify\",\n    value: function verify(address, callback) {\n      this.command(\"vrfy \".concat(address), callback, [250, 251, 252]);\n    }\n    /**\n     * @public\n     * @description SMTP 'expn' command -- expands a mailing list.\n     * @param {string} address the mailing list to expand\n     * @param {function(...any[]): void} callback function to call after response\n     * @returns {void}\n     */\n\n  }, {\n    key: \"expn\",\n    value: function expn(address, callback) {\n      this.command(\"expn \".concat(address), callback);\n    }\n    /**\n     * @public\n     * @description Calls this.ehlo() and, if an error occurs, this.helo().\n     *\n     * If there has been no previous EHLO or HELO command self session, self\n     * method tries ESMTP EHLO first.\n     *\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {string} [domain] the domain to associate with the command\n     * @returns {void}\n     */\n\n  }, {\n    key: \"ehlo_or_helo_if_needed\",\n    value: function ehlo_or_helo_if_needed(callback, domain) {\n      var _this12 = this;\n\n      // is this code callable...?\n      if (!this.features) {\n        var response = function response(err, data) {\n          return caller(callback, err, data);\n        };\n\n        this.ehlo(function (err, data) {\n          if (err) {\n            _this12.helo(response, domain);\n          } else {\n            caller(callback, err, data);\n          }\n        }, domain);\n      }\n    }\n    /**\n     * @public\n     *\n     * Log in on an SMTP server that requires authentication.\n     *\n     * If there has been no previous EHLO or HELO command self session, self\n     * method tries ESMTP EHLO first.\n     *\n     * This method will return normally if the authentication was successful.\n     *\n     * @param {function(...any[]): void} callback function to call after response\n     * @param {string} [user] the username to authenticate with\n     * @param {string} [password] the password for the authentication\n     * @param {{ method: string, domain: string }} [options] login options\n     * @returns {void}\n     */\n\n  }, {\n    key: \"login\",\n    value: function login(callback, user, password) {\n      var _this13 = this;\n\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var _a, _b;\n\n      var login = {\n        user: user ? function () {\n          return user;\n        } : this.user,\n        password: password ? function () {\n          return password;\n        } : this.password,\n        method: (_b = (_a = options === null || options === void 0 ? void 0 : options.method) === null || _a === void 0 ? void 0 : _a.toUpperCase()) !== null && _b !== void 0 ? _b : ''\n      };\n      var domain = (options === null || options === void 0 ? void 0 : options.domain) || this.domain;\n\n      var initiate = function initiate(err, data) {\n        var _a;\n\n        if (err) {\n          caller(callback, err);\n          return;\n        }\n\n        var method = null;\n        /**\n         * @param {string} challenge challenge\n         * @returns {string} base64 cram hash\n         */\n\n        var encodeCramMd5 = function encodeCramMd5(challenge) {\n          var hmac = createHmac('md5', login.password());\n          hmac.update(Buffer.from(challenge, 'base64').toString('ascii'));\n          return Buffer.from(\"\".concat(login.user(), \" \").concat(hmac.digest('hex'))).toString('base64');\n        };\n        /**\n         * @returns {string} base64 login/password\n         */\n\n\n        var encodePlain = function encodePlain() {\n          return Buffer.from(\"\\0\".concat(login.user(), \"\\0\").concat(login.password())).toString('base64');\n        };\n        /**\n         * @see https://developers.google.com/gmail/xoauth2_protocol\n         * @returns {string} base64 xoauth2 auth token\n         */\n\n\n        var encodeXoauth2 = function encodeXoauth2() {\n          return Buffer.from(\"user=\".concat(login.user(), \"\\x01auth=Bearer \").concat(login.password(), \"\\x01\\x01\")).toString('base64');\n        }; // List of authentication methods we support: from preferred to\n        // less preferred methods.\n\n\n        if (!method) {\n          var preferred = _this13.authentication;\n          var auth = '';\n\n          if (typeof ((_a = _this13.features) === null || _a === void 0 ? void 0 : _a['auth']) === 'string') {\n            auth = _this13.features['auth'];\n          }\n\n          for (var i = 0; i < preferred.length; i++) {\n            if (auth.includes(preferred[i])) {\n              method = preferred[i];\n              break;\n            }\n          }\n        }\n        /**\n         * handle bad responses from command differently\n         * @param {Error} err err\n         * @param {unknown} data data\n         * @returns {void}\n         */\n\n\n        var failed = function failed(err, data) {\n          _this13.loggedin = false;\n\n          _this13.close(); // if auth is bad, close the connection, it won't get better by itself\n\n\n          err.message = err.message.replace(_this13.password(), 'REDACTED');\n          caller(callback, SMTPError.create('authorization.failed', SMTPErrorStates.AUTHFAILED, err, data));\n        };\n        /**\n         * @param {Error} err err\n         * @param {unknown} data data\n         * @returns {void}\n         */\n\n\n        var response = function response(err, data) {\n          if (err) {\n            failed(err, data);\n          } else {\n            _this13.loggedin = true;\n            caller(callback, err, data);\n          }\n        };\n        /**\n         * @param {Error} err err\n         * @param {unknown} data data\n         * @param {string} msg msg\n         * @returns {void}\n         */\n\n\n        var attempt = function attempt(err, data, msg) {\n          if (err) {\n            failed(err, data);\n          } else {\n            if (method === AUTH_METHODS['CRAM-MD5']) {\n              _this13.command(encodeCramMd5(msg), response, [235, 503]);\n            } else if (method === AUTH_METHODS.LOGIN) {\n              _this13.command(Buffer.from(login.password()).toString('base64'), response, [235, 503]);\n            }\n          }\n        };\n        /**\n         * @param {Error} err err\n         * @param {unknown} data data\n         * @param {string} msg msg\n         * @returns {void}\n         */\n\n\n        var attemptUser = function attemptUser(err, data) {\n          if (err) {\n            failed(err, data);\n          } else {\n            if (method === AUTH_METHODS.LOGIN) {\n              _this13.command(Buffer.from(login.user()).toString('base64'), attempt, [334]);\n            }\n          }\n        };\n\n        switch (method) {\n          case AUTH_METHODS['CRAM-MD5']:\n            _this13.command(\"AUTH  \".concat(AUTH_METHODS['CRAM-MD5']), attempt, [334]);\n\n            break;\n\n          case AUTH_METHODS.LOGIN:\n            _this13.command(\"AUTH \".concat(AUTH_METHODS.LOGIN), attemptUser, [334]);\n\n            break;\n\n          case AUTH_METHODS.PLAIN:\n            _this13.command(\"AUTH \".concat(AUTH_METHODS.PLAIN, \" \").concat(encodePlain()), response, [235, 503]);\n\n            break;\n\n          case AUTH_METHODS.XOAUTH2:\n            _this13.command(\"AUTH \".concat(AUTH_METHODS.XOAUTH2, \" \").concat(encodeXoauth2()), response, [235, 503]);\n\n            break;\n\n          default:\n            caller(callback, SMTPError.create('no form of authorization supported', SMTPErrorStates.AUTHNOTSUPPORTED, null, data));\n            break;\n        }\n      };\n\n      this.ehlo_or_helo_if_needed(initiate, domain);\n    }\n    /**\n     * @public\n     * @param {boolean} [force=false] whether or not to force destroy the connection\n     * @returns {void}\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.sock) {\n        if (force) {\n          this.log('smtp connection destroyed!');\n          this.sock.destroy();\n        } else {\n          this.log('smtp connection closed.');\n          this.sock.end();\n        }\n      }\n\n      if (this.monitor) {\n        this.monitor.stop();\n        this.monitor = null;\n      }\n\n      this._state = SMTPState.NOTCONNECTED;\n      this._secure = false;\n      this.sock = null;\n      this.features = null;\n      this.loggedin = !(this.user() && this.password());\n    }\n    /**\n     * @public\n     * @param {function(...any[]): void} [callback] function to call after response\n     * @returns {void}\n     */\n\n  }, {\n    key: \"quit\",\n    value: function quit(callback) {\n      var _this14 = this;\n\n      this.command('quit', function (err, data) {\n        caller(callback, err, data);\n\n        _this14.close();\n      }, [221, 250]);\n    }\n  }]);\n\n  return SMTPConnection;\n}(EventEmitter);\n\nvar SMTPClient = /*#__PURE__*/function () {\n  /**\n   * Create a standard SMTP client backed by a self-managed SMTP connection.\n   *\n   * NOTE: `host` is trimmed before being used to establish a connection; however, the original untrimmed value will still be visible in configuration.\n   *\n   * @param {SMTPConnectionOptions} server smtp options\n   */\n  function SMTPClient(server) {\n    _classCallCheck(this, SMTPClient);\n\n    this.queue = [];\n    this.sending = false;\n    this.ready = false;\n    this.timer = null;\n    this.smtp = new SMTPConnection(server);\n  }\n  /**\n   * @public\n   * @template {Message | MessageHeaders} T\n   * @param {T} msg the message to send\n   * @param {MessageCallback<T>} callback receiver for the error (if any) as well as the passed-in message / headers\n   * @returns {void}\n   */\n\n\n  _createClass(SMTPClient, [{\n    key: \"send\",\n    value: function send(msg, callback) {\n      var message = msg instanceof Message ? msg : this._canMakeMessage(msg) ? new Message(msg) : null;\n\n      if (message == null) {\n        callback(new Error('message is not a valid Message instance'), msg);\n        return;\n      }\n\n      var _message$checkValidit = message.checkValidity(),\n          isValid = _message$checkValidit.isValid,\n          validationError = _message$checkValidit.validationError;\n\n      if (isValid) {\n        var stack = this.createMessageStack(message, callback);\n\n        if (stack.to.length === 0) {\n          return callback(new Error('No recipients found in message'), msg);\n        }\n\n        this.queue.push(stack);\n\n        this._poll();\n      } else {\n        callback(new Error(validationError), msg);\n      }\n    }\n    /**\n     * @public\n     * @template {Message | MessageHeaders} T\n     * @param {T} msg the message to send\n     * @returns {Promise<T>} a promise that resolves to the passed-in message / headers\n     */\n\n  }, {\n    key: \"sendAsync\",\n    value: function sendAsync(msg) {\n      var _this15 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this15.send(msg, function (err, message) {\n          if (err != null) {\n            reject(err);\n          } else {\n            // unfortunately, the conditional type doesn't reach here\n            // fortunately, we only return a `Message` when err is null, so this is safe\n            resolve(message);\n          }\n        });\n      });\n    }\n    /**\n     * @public\n     * @description Converts a message to the raw object used by the internal stack.\n     * @param {Message} message message to convert\n     * @param {MessageCallback} callback errback\n     * @returns {MessageStack} raw message object\n     */\n\n  }, {\n    key: \"createMessageStack\",\n    value: function createMessageStack(message) {\n      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        /*  */\n      };\n\n      var _addressparser = addressparser(message.header.from),\n          _addressparser2 = _slicedToArray(_addressparser, 1),\n          from = _addressparser2[0].address;\n\n      var stack = {\n        message: message,\n        to: [],\n        from: from,\n        callback: callback.bind(this)\n      };\n      var _message$header = message.header,\n          to = _message$header.to,\n          cc = _message$header.cc,\n          bcc = _message$header.bcc,\n          returnPath = _message$header['return-path'];\n\n      if ((typeof to === 'string' || Array.isArray(to)) && to.length > 0) {\n        stack.to = addressparser(to);\n      }\n\n      if ((typeof cc === 'string' || Array.isArray(cc)) && cc.length > 0) {\n        stack.to = stack.to.concat(addressparser(cc).filter(function (x) {\n          return stack.to.some(function (y) {\n            return y.address === x.address;\n          }) === false;\n        }));\n      }\n\n      if ((typeof bcc === 'string' || Array.isArray(bcc)) && bcc.length > 0) {\n        stack.to = stack.to.concat(addressparser(bcc).filter(function (x) {\n          return stack.to.some(function (y) {\n            return y.address === x.address;\n          }) === false;\n        }));\n      }\n\n      if (typeof returnPath === 'string' && returnPath.length > 0) {\n        var parsedReturnPath = addressparser(returnPath);\n\n        if (parsedReturnPath.length > 0) {\n          var _parsedReturnPath = _slicedToArray(parsedReturnPath, 1),\n              returnPathAddress = _parsedReturnPath[0].address;\n\n          stack.returnPath = returnPathAddress;\n        }\n      }\n\n      return stack;\n    }\n    /**\n     * @protected\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_poll\",\n    value: function _poll() {\n      var _this16 = this;\n\n      if (this.timer != null) {\n        clearTimeout(this.timer);\n      }\n\n      if (this.queue.length) {\n        if (this.smtp.state() == SMTPState.NOTCONNECTED) {\n          this._connect(this.queue[0]);\n        } else if (this.smtp.state() == SMTPState.CONNECTED && !this.sending && this.ready) {\n          this._sendmail(this.queue.shift());\n        }\n      } // wait around 1 seconds in case something does come in,\n      // otherwise close out SMTP connection if still open\n      else if (this.smtp.state() == SMTPState.CONNECTED) {\n        this.timer = setTimeout(function () {\n          return _this16.smtp.quit();\n        }, 1000);\n      }\n    }\n    /**\n     * @protected\n     * @param {MessageStack} stack stack\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_connect\",\n    value: function _connect(stack) {\n      var _this17 = this;\n\n      /**\n       * @param {Error} err callback error\n       * @returns {void}\n       */\n      var connect = function connect(err) {\n        if (!err) {\n          var begin = function begin(err) {\n            if (!err) {\n              _this17.ready = true;\n\n              _this17._poll();\n            } else {\n              stack.callback(err, stack.message); // clear out the queue so all callbacks can be called with the same error message\n\n              _this17.queue.shift();\n\n              _this17._poll();\n            }\n          };\n\n          if (!_this17.smtp.authorized()) {\n            _this17.smtp.login(begin);\n          } else {\n            _this17.smtp.ehlo_or_helo_if_needed(begin);\n          }\n        } else {\n          stack.callback(err, stack.message); // clear out the queue so all callbacks can be called with the same error message\n\n          _this17.queue.shift();\n\n          _this17._poll();\n        }\n      };\n\n      this.ready = false;\n      this.smtp.connect(connect);\n    }\n    /**\n     * @protected\n     * @param {MessageStack} msg message stack\n     * @returns {boolean} can make message\n     */\n\n  }, {\n    key: \"_canMakeMessage\",\n    value: function _canMakeMessage(msg) {\n      return msg.from && (msg.to || msg.cc || msg.bcc) && (msg.text !== undefined || this._containsInlinedHtml(msg.attachment));\n    }\n    /**\n     * @protected\n     * @param {MessageAttachment | MessageAttachment[]} attachment attachment\n     * @returns {boolean} whether the attachment contains inlined html\n     */\n\n  }, {\n    key: \"_containsInlinedHtml\",\n    value: function _containsInlinedHtml(attachment) {\n      var _this18 = this;\n\n      if (Array.isArray(attachment)) {\n        return attachment.some(function (att) {\n          return _this18._isAttachmentInlinedHtml(att);\n        });\n      } else {\n        return this._isAttachmentInlinedHtml(attachment);\n      }\n    }\n    /**\n     * @protected\n     * @param {MessageAttachment} attachment attachment\n     * @returns {boolean} whether the attachment is inlined html\n     */\n\n  }, {\n    key: \"_isAttachmentInlinedHtml\",\n    value: function _isAttachmentInlinedHtml(attachment) {\n      return attachment && (attachment.data || attachment.path) && attachment.alternative === true;\n    }\n    /**\n     * @protected\n     * @param {MessageStack} stack stack\n     * @param {function(MessageStack): void} next next\n     * @returns {function(Error): void} callback\n     */\n\n  }, {\n    key: \"_sendsmtp\",\n    value: function _sendsmtp(stack, next) {\n      var _this19 = this;\n\n      /**\n       * @param {Error} [err] error\n       * @returns {void}\n       */\n      return function (err) {\n        if (!err && next) {\n          next.apply(_this19, [stack]);\n        } else {\n          // if we snag on SMTP commands, call done, passing the error\n          // but first reset SMTP state so queue can continue polling\n          _this19.smtp.rset(function () {\n            return _this19._senddone(err, stack);\n          });\n        }\n      };\n    }\n    /**\n     * @protected\n     * @param {MessageStack} stack stack\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_sendmail\",\n    value: function _sendmail(stack) {\n      var from = stack.returnPath || stack.from;\n      this.sending = true;\n      this.smtp.mail(this._sendsmtp(stack, this._sendrcpt), '<' + from + '>');\n    }\n    /**\n     * @protected\n     * @param {MessageStack} stack stack\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_sendrcpt\",\n    value: function _sendrcpt(stack) {\n      var _a;\n\n      if (stack.to == null || typeof stack.to === 'string') {\n        throw new TypeError('stack.to must be array');\n      }\n\n      var to = (_a = stack.to.shift()) === null || _a === void 0 ? void 0 : _a.address;\n      this.smtp.rcpt(this._sendsmtp(stack, stack.to.length ? this._sendrcpt : this._senddata), \"<\".concat(to, \">\"));\n    }\n    /**\n     * @protected\n     * @param {MessageStack} stack stack\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_senddata\",\n    value: function _senddata(stack) {\n      this.smtp.data(this._sendsmtp(stack, this._sendmessage));\n    }\n    /**\n     * @protected\n     * @param {MessageStack} stack stack\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_sendmessage\",\n    value: function _sendmessage(stack) {\n      var _this20 = this;\n\n      var stream = stack.message.stream();\n      stream.on('data', function (data) {\n        return _this20.smtp.message(data);\n      });\n      stream.on('end', function () {\n        _this20.smtp.data_end(_this20._sendsmtp(stack, function () {\n          return _this20._senddone(null, stack);\n        }));\n      }); // there is no way to cancel a message while in the DATA portion,\n      // so we have to close the socket to prevent a bad email from going out\n\n      stream.on('error', function (err) {\n        _this20.smtp.close();\n\n        _this20._senddone(err, stack);\n      });\n    }\n    /**\n     * @protected\n     * @param {Error} err err\n     * @param {MessageStack} stack stack\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_senddone\",\n    value: function _senddone(err, stack) {\n      this.sending = false;\n      stack.callback(err, stack.message);\n\n      this._poll();\n    }\n  }]);\n\n  return SMTPClient;\n}();\n\nexport { AUTH_METHODS, BUFFERSIZE, DEFAULT_TIMEOUT, MIME64CHUNK, MIMECHUNK, Message, SMTPClient, SMTPConnection, SMTPError, SMTPErrorStates, SMTPResponseMonitor, SMTPState, addressparser, getRFC2822Date, getRFC2822DateUTC, isRFC2822Date, mimeEncode, mimeWordEncode }; //# sourceMappingURL=email.js.map","map":null,"metadata":{},"sourceType":"module"}